{
  "search-in-rotated-sorted-array": "class Solution {\n    public int search(int[] arr, int target) {\n        int n = arr.length;\n        int pivot = findPivot(arr);\n        if (pivot == -1) {\n            return binarysearch(arr, 0, n - 1, target);\n        }\n        if (arr[pivot] == target) {\n            return pivot;\n        }\n        if (target >= arr[0]) {\n            return binarysearch(arr, 0, pivot - 1, target);\n        }\n        return binarysearch(arr, pivot + 1, n - 1, target);\n    }\n\n    private int findPivot(int[] arr) {\n        int l = 0, r = arr.length - 1;\n        while (l < r) {\n            int mid = l + (r - l) / 2;\n            if (arr[mid] > arr[r]) {\n                l = mid + 1;\n            } else {\n                r = mid;\n            }\n        }\n        return (l == 0) ? -1 : l - 1;\n    }\n\n    public int binarysearch(int arr[], int left, int right, int x) {\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (arr[mid] == x)\n                return mid;\n            else if (arr[mid] < x)\n                left = mid + 1;\n            else\n                right = mid - 1;\n        }\n        return -1;\n    }\n}",
  "minimum-adjacent-swaps-to-alternate-parity": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public int minSwaps(int[] nums) {\n        int n = nums.length;\n        List<Integer> evenIndices = new ArrayList<>();\n        List<Integer> oddIndices = new ArrayList<>();\n\n        for (int i = 0; i < n; i++) {\n            if (nums[i] % 2 == 0) {\n                evenIndices.add(i);\n            } else {\n                oddIndices.add(i);\n            }\n        }\n\n        int evenCount = evenIndices.size();\n        int oddCount = oddIndices.size();\n\n        if (Math.abs(evenCount - oddCount) > 1) {\n            return -1;\n        }\n\n        // Case 1: Target starts with Even (E, O, E, O...)\n        long swaps1 = Long.MAX_VALUE;\n        if (evenCount >= oddCount) { // This pattern is possible\n            swaps1 = 0;\n            // Calculate moves for odd numbers to get to odd positions\n            for (int i = 0; i < oddCount; i++) {\n                int targetIndex = 2 * i + 1;\n                swaps1 += Math.abs(oddIndices.get(i) - targetIndex);\n            }\n        }\n\n        // Case 2: Target starts with Odd (O, E, O, E...)\n        long swaps2 = Long.MAX_VALUE;\n        if (oddCount >= evenCount) { // This pattern is possible\n            swaps2 = 0;\n            // Calculate moves for even numbers to get to odd positions\n            for (int i = 0; i < evenCount; i++) {\n                int targetIndex = 2 * i + 1;\n                swaps2 += Math.abs(evenIndices.get(i) - targetIndex);\n            }\n        }\n\n        long result = Math.min(swaps1, swaps2);\n        return result == Long.MAX_VALUE ? -1 : (int) result;\n    }\n}\n"
}